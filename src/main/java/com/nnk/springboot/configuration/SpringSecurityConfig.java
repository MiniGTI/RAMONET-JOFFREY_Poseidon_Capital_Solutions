package com.nnk.springboot.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

import java.util.HashSet;
import java.util.Set;

/**
 * Configuration class to secure the authentication with SpringBoot Security by session based.
 */
@Configuration
@EnableWebSecurity
public class SpringSecurityConfig {
    
    private final CustomUserDetailsService customUserDetailsService;
    
    private final AuthenticationSuccessHandler successHandler;
    
    public SpringSecurityConfig(CustomUserDetailsService customUserDetailsService,
                                AuthenticationSuccessHandler successHandler) {
        this.customUserDetailsService = customUserDetailsService;
        this.successHandler = successHandler;
    }
    
    /**
     * Method to configure the authentication and restrictions.
     * Only the loginPage, generated by default is allowed for all.
     *
     * @param http HttpSecurity.class call, allows to apply the security filter string to HTTP requests.
     * @return a filter configuration.
     * @throws Exception generated by authorizeHttpRequests.
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http.sessionManagement(session -> {
                    session.sessionCreationPolicy(SessionCreationPolicy.ALWAYS);
                })
                .authorizeHttpRequests(auth -> {
                    auth.requestMatchers("/bidList/*", "/curvePoint/*", "/rating/*", "/ruleName/*", "/trade/*")
                            .hasRole("USER");
                    auth.requestMatchers("/home", "/user/*", "/")
                            .hasRole("ADMIN");
                    auth.anyRequest()
                            .authenticated();
                })
                .formLogin(form -> {
                    form.successHandler(successHandler);
                })
                .oauth2Login(oa -> {
                    oa.userInfoEndpoint((userInfo) -> userInfo.userAuthoritiesMapper(OAuth2GrantedAuthoritiesMapper()));
                    oa.successHandler(successHandler);
                })
                .exceptionHandling(ex -> {
                    ex.accessDeniedPage("/error403");
                })
                .logout(logout -> {
                    logout.logoutUrl("/logout");
                    logout.logoutSuccessUrl("/login?logout");
                    logout.invalidateHttpSession(true);
                    logout.deleteCookies("JSESSIONID");
                })
                .build();
    }
    
    /**
     * Bean to encode password.
     * Used to save password encoded in the User table.
     *
     * @return An encoder.
     */
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    /**
     * List of role authorisation for OAuth2 authentication.
     *
     * @return a list of one role, ROLE_USER.
     */
    public GrantedAuthoritiesMapper OAuth2GrantedAuthoritiesMapper() {
        
        Set<GrantedAuthority> mappedAuthorities = new HashSet<>();
        
        mappedAuthorities.add(new SimpleGrantedAuthority("ROLE_USER"));
        
        return (authorities) -> mappedAuthorities;
    }
    
    
    /**
     * Methode to valid or not the authentication of the customDetailsService.
     *
     * @param http                  HttpSecurity.class call, allows to apply the security filter string to HTTP requests.
     * @param bCryptPasswordEncoder The password encoder.
     * @return authenticationManagerBuilder, give the authentication.
     * @throws Exception can be lifted by  userDetailsService and build.
     */
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http, BCryptPasswordEncoder bCryptPasswordEncoder)
            throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder.userDetailsService(customUserDetailsService)
                .passwordEncoder(bCryptPasswordEncoder);
        return authenticationManagerBuilder.build();
    }
}
